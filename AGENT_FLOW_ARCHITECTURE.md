# ðŸ¤– Agent + Firestore Flow Architecture

## The Complete Information Flow

This document explains how data flows between users, Firestore, and AI agents in HomerIDE.

---

## ðŸ“Š High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User UI   â”‚ â—„â”€â”€â”€â”€â”€â–º â”‚  FIRESTORE   â”‚ â—„â”€â”€â”€â”€â”€â–º â”‚  AI Agent   â”‚
â”‚  (React)    â”‚         â”‚  (Database)  â”‚         â”‚  (Backend)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     Real-time            Single Source            Processes &
     Updates              of Truth                 Generates Code
```

**Key Concept:** Firestore is the **single source of truth**. Both UI and agents read/write to it.

---

## ðŸ”„ Complete Flow: User Prompt â†’ Code Generation

### **Step-by-Step Flow:**

```
1. User Types Prompt
   â†“
2. FloatingInput saves to Firestore
   {
     collection: sessions/{sessionId}/prompts
     data: {
       content: "Add a blue button",
       status: "pending",
       userId: "user-123",
       createdAt: timestamp
     }
   }
   â†“
3. AI Agent Watches Firestore (Real-time listener)
   - Agent detects new prompt with status="pending"
   â†“
4. Agent Updates Status â†’ "processing"
   â†“
5. Agent Reads Current State from Firestore
   - Gets all files from sessions/{sessionId}/files
   - Gets product spec from sessions/{sessionId}
   - Gets context about current feature
   â†“
6. Agent Calls OpenAI/Claude API
   Context sent to AI:
   {
     existingFiles: [...all current code files],
     productSpec: "...",
     currentFeature: "User Authentication",
     userPrompt: "Add a blue button"
   }
   â†“
7. AI API Returns Updated Code
   {
     files: [
       {path: "src/App.tsx", content: "...updated code..."},
       {path: "src/Button.tsx", content: "...new file..."}
     ],
     explanation: "I added a blue button component..."
   }
   â†“
8. Agent Writes Back to Firestore
   - Updates existing files
   - Creates new files
   - Updates product spec if needed
   â†“
9. Agent Updates Prompt Status â†’ "completed"
   â†“
10. UI Auto-Updates (Real-time listeners)
    - QueueView shows "completed"
    - FileView shows new files
    - StackBlitz recompiles
    - Preview updates automatically
```

---

## ðŸ—„ï¸ Firestore Data Structure

```javascript
sessions/
  {sessionId}/
    // Session metadata
    - initialPrompt: string
    - projectSpec: string  // Generated by agent
    - features: array      // Generated by agent
    - createdAt: timestamp
    
    // Subcollections
    files/               // All code files
      {fileId}/
        - path: "src/App.tsx"
        - content: "import React..."  // Generated by agent
        - language: "typescript"
        - updatedAt: timestamp
        - updatedBy: "agent" | "user"
    
    prompts/            // User requests
      {promptId}/
        - content: "Add a blue button"
        - status: "pending" | "processing" | "completed" | "error"
        - userId: string
        - createdAt: timestamp
        - completedAt: timestamp | null
    
    messages/           // Chat history (optional)
      {messageId}/
        - role: "user" | "assistant"
        - content: string
        - createdAt: timestamp
```

---

## ðŸ¤– Agent Implementation Options

### **Option 1: Frontend Agent (Fastest for Hackathon)**

**Pros:**
- âœ… No backend deployment
- âœ… Direct Firestore access
- âœ… Fast to implement (15 min)

**Cons:**
- âŒ API key exposed in browser (use for demo only)
- âŒ Limited to browser resources

**Code Location:** `src/services/aiAgent.ts`

**How it works:**
```typescript
// Agent runs in browser, watches Firestore
const { prompts } = useFirestorePrompts(sessionId);

useEffect(() => {
  const pendingPrompt = prompts.find(p => p.status === 'pending');
  if (pendingPrompt) {
    processPrompt(pendingPrompt);
  }
}, [prompts]);
```

---

### **Option 2: Backend Agent (Production-Ready)**

**Pros:**
- âœ… Secure API keys
- âœ… More processing power
- âœ… Can run long tasks

**Cons:**
- âŒ Requires deployment
- âŒ More complex setup

**Options:**
1. **Supabase Edge Function** (Deno)
2. **Vercel Serverless Function** (Node.js)
3. **Firebase Cloud Function** (Node.js)
4. **Separate Node.js Server**

**How it works:**
```javascript
// Backend watches Firestore for new prompts
const unsubscribe = db.collection('sessions')
  .doc(sessionId)
  .collection('prompts')
  .where('status', '==', 'pending')
  .onSnapshot(async (snapshot) => {
    for (const doc of snapshot.docs) {
      await processPrompt(doc.id, doc.data());
    }
  });
```

---

## ðŸ“ What Each Component Does

### **User Interface (React)**
```typescript
// READ from Firestore:
- useFirestoreFiles()     â†’ Get all code files
- useFirestorePrompts()   â†’ Get prompt queue
- useFirestoreSession()   â†’ Get project metadata

// WRITE to Firestore:
- addPrompt()             â†’ New user request
- (Optional) updateFile() â†’ Manual code edits
```

### **AI Agent (Backend/Frontend)**
```typescript
// READ from Firestore:
- Get pending prompts
- Get all current files
- Get product spec
- Get context

// WRITE to Firestore:
- Update prompt status
- Create/update files
- Update product spec
- Add chat messages
```

### **Firestore**
```typescript
// Provides:
- Real-time sync (onSnapshot)
- Persistence
- Conflict resolution
- Offline support
```

---

## ðŸ”¥ Agent Processing Logic

```typescript
async function processPrompt(promptId, promptData) {
  // 1. Mark as processing
  await updatePromptStatus(promptId, 'processing');
  
  // 2. Gather context
  const files = await getAllFiles(sessionId);
  const session = await getSession(sessionId);
  
  // 3. Build AI context
  const context = {
    systemPrompt: "You are a React code generator...",
    currentFiles: files.map(f => `${f.path}:\n${f.content}`).join('\n\n'),
    productSpec: session.projectSpec,
    userPrompt: promptData.content
  };
  
  // 4. Call AI API
  const response = await callOpenAI(context);
  
  // 5. Parse AI response
  const { files: updatedFiles, explanation } = JSON.parse(response);
  
  // 6. Update Firestore
  for (const file of updatedFiles) {
    await updateOrCreateFile(sessionId, file);
  }
  
  // 7. Mark as completed
  await updatePromptStatus(promptId, 'completed');
  
  // 8. (Optional) Add explanation to chat
  await addMessage(sessionId, {
    role: 'assistant',
    content: explanation
  });
}
```

---

## ðŸŽ¯ What Gets Mocked vs. Generated

### **Currently Mocked (Will Be Generated by Agent):**

1. **Product Spec** (`DocumentView.tsx`)
   ```typescript
   // MOCK:
   const spec = "Product Specification\nCore Features: ...";
   
   // AGENT WILL:
   - Generate from initial prompt
   - Update as user adds features
   - Store in: sessions/{id}/projectSpec
   ```

2. **Feature List** (`DocumentView.tsx`)
   ```typescript
   // MOCK:
   const features = ["User Auth", "Real-time Collaboration"];
   
   // AGENT WILL:
   - Extract from product spec
   - Store in: sessions/{id}/features[]
   ```

3. **Initial Code Files** (`Hero.tsx` - seedReactFiles)
   ```typescript
   // MOCK: Hardcoded React template
   
   // AGENT WILL:
   - Generate from initial prompt
   - Create appropriate file structure
   - Write actual implementation
   ```

### **Already Working (Real Data):**

1. âœ… **Session creation** - Firestore
2. âœ… **File storage** - Firestore
3. âœ… **Prompt queue** - Firestore
4. âœ… **Live preview** - StackBlitz
5. âœ… **Real-time sync** - Firestore listeners

---

## ðŸš€ Quick Start: Adding Agent Integration

### **Step 1: Create Agent Service** (Frontend approach)

Create `src/services/aiAgent.ts`:

```typescript
import { collection, doc, getDocs, updateDoc, Timestamp } from 'firebase/firestore';
import { db } from '@/integrations/firebase/config';

export class AIAgent {
  private sessionId: string;
  private apiKey: string;

  constructor(sessionId: string) {
    this.sessionId = sessionId;
    this.apiKey = import.meta.env.VITE_OPENAI_API_KEY;
  }

  async processPrompt(promptId: string, promptContent: string) {
    // Mark as processing
    await this.updatePromptStatus(promptId, 'processing');
    
    // Get current state
    const files = await this.getCurrentFiles();
    const context = this.buildContext(files, promptContent);
    
    // Call AI
    const response = await this.callOpenAI(context);
    
    // Update files
    await this.updateFiles(response.files);
    
    // Mark as completed
    await this.updatePromptStatus(promptId, 'completed');
  }
  
  private async getCurrentFiles() {
    const filesRef = collection(db, 'sessions', this.sessionId, 'files');
    const snapshot = await getDocs(filesRef);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  }
  
  private async updatePromptStatus(promptId: string, status: string) {
    const promptRef = doc(db, 'sessions', this.sessionId, 'prompts', promptId);
    await updateDoc(promptRef, { status, completedAt: Timestamp.now() });
  }
  
  // ... more methods
}
```

### **Step 2: Watch for New Prompts**

In your workspace or a dedicated component:

```typescript
import { useFirestorePrompts } from '@/hooks/useFirestorePrompts';
import { AIAgent } from '@/services/aiAgent';

const { prompts } = useFirestorePrompts(sessionId);
const [processing, setProcessing] = useState(false);

useEffect(() => {
  if (!sessionId || processing) return;
  
  const pendingPrompt = prompts.find(p => p.status === 'pending');
  if (pendingPrompt) {
    setProcessing(true);
    const agent = new AIAgent(sessionId);
    agent.processPrompt(pendingPrompt.id, pendingPrompt.content)
      .then(() => setProcessing(false))
      .catch(err => {
        console.error('Agent error:', err);
        setProcessing(false);
      });
  }
}, [prompts, sessionId, processing]);
```

### **Step 3: Test the Flow**

1. Type a prompt: "Add a red button"
2. Check Firestore Console â†’ prompts collection (status: "pending")
3. Agent detects it â†’ status changes to "processing"
4. Agent updates files â†’ new code in files collection
5. StackBlitz auto-reloads â†’ see the red button!
6. QueueView shows "completed"

---

## ðŸ“ˆ Scaling Considerations

### **For Hackathon (Next 2 Hours):**
- Use **frontend agent** with OpenAI API
- Store API key in `.env.local`
- Process one prompt at a time
- Simple error handling

### **For Production:**
- Move agent to **backend**
- Use job queue (Firebase Queue)
- Handle concurrent prompts
- Implement retry logic
- Add rate limiting
- Proper error recovery

---

## ðŸŽ“ Summary

**Information Flow:**
```
User â†’ FloatingInput â†’ Firestore (prompt)
                           â†“
                    Agent detects
                           â†“
                    Agent reads files
                           â†“
                    Agent calls AI API
                           â†“
                    Agent writes files
                           â†“
           Firestore (updated code) â†’ UI updates
                                      â†’ StackBlitz recompiles
                                      â†’ User sees changes
```

**Key Principles:**
1. âœ… Firestore is single source of truth
2. âœ… Everything is real-time (onSnapshot listeners)
3. âœ… Agent and UI never talk directly
4. âœ… All communication through Firestore
5. âœ… UI automatically updates when data changes

---

Ready to add the agent? Check `AI_AGENT_GUIDE.md` for complete implementation code!

